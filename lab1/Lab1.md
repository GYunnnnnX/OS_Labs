#                                                      操作系统课程ucore Lab1

## 练习一

### Q1：说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？

`la sp, bootstacktop` 指令完成的操作是：将 `bootstacktop` 的地址加载到寄存器 `sp`（`stack pointer`，栈指针）中，
即设置当前栈指针指向内核启动栈的顶部地址。

其中的`la`是RISC-V中的汇编伪指令，意思是`load address`。

### Q2：tail kern_init 完成了什么操作，目的是什么？

`tail kern_init` 指令完成的操作是：跳转到`kern_init`并不保存返回地址，即按照RISC-V的调用约定跳转到`kern_init()`函数。

其中的`tail`是 RISC-V 汇编伪指令，相当于：`j kern_init`，但语义上等价于“跳转并不返回”，执行一个无返回的函数调用（尾调用优化）。

编译器/汇编器会把它翻译为：
`auipc  ra, 0`
`jalr   x0, kern_init`
即跳转到`kern_init`并不保存返回地址（在操作系统内核启动时，引导程序调用后不再返回。内核一旦运行，就不会回到汇编入口）。



## 练习二

### 实验过程：

#### 运行终端命令：

首先，我们使用的是VS Code和unbuntu虚拟机，可以很方便地开两个终端。

- 第一个终端，我们输入`make debug`命令，启动`QEMU`。在指导书中，我们了解到：这里的参数`-S`会让虚拟`CPU`一启动就立刻暂停(等待进一步命令)；而参数`-s`则告诉`QEMU`：“打开`1234`端口，准备接受`GDB`的连接”。在运行命令后，VS Code提示：“**在端口`1234`上运行的应用程序可用**”，说明`1234`端口现在已经打开，可以接受连接。

- 第二个终端，我们输入`make gdb`。在指导书中，我们了解到这个命令其实是一系列操作的集合：

	“`file bin/kernel`：让`GDB`加载我们编译好的内核文件，这个文件里包含宝贵的调试符号（函数名、变量名等）。

	​     `set arch riscv:rv64`：告诉`GDB`，我们要调试的是`RISC-V 64`位的程序。

	​     `target remote localhost:1234`：让`GDB`去连接本机（`localhost`）的`1234`端口，也就是`QEMU`正在等待我们的地方。”

	​     输入命令后，它的显示中有两行是：

 “`Remote debugging using localhost:1234`

 `0x0000000000001000 in ?? ()`”

 告诉我们现在程序停在了地址`0x1000`（`QEMU`内置的固件（`BIOS`）代码）这个地方，还没执行到我们的内核。

![image-20251009221101435](./img/image-20251009221101435.png)

#### 打断点：

在gdb中，我们使用命令`(gdb)b* kern_entry`打下断点。其中，`b`是`break`的缩写，`kern_entry`是函数名。这里我们可以直接对`kern_entry`函数下断点，是由于编译器已经帮我们把函数名和地址对应起来了（调试符号）。

这时候，gdb会输出`Breakpoint 1 at 0x80200000: file kern/init/entry.S, line 7.`告诉我们已经在`0x80200000`处打好了断点，对应着`entry.S`中函数`kern_entry`的地址，也是内核的入口地址。

![image-20251009220941701](./img/image-20251009220941701.png)

#### 执行程序：

执行`continue`(缩写为`c`)命令，开始执行程序。gdb输出如下：

“`Continuing.`

`Breakpoint 1, kern_entry () at kern/init/entry.S:7`
`7           la sp, bootstacktop`”

可见，内核运行到了我们设置好的断点处（入口函数的第一条汇编指令）停止，我们可以检查寄存器状态或反汇编附近的代码。

在指导书中提示到：“寄存器是 `CPU` 内部的高速存储单元，存放当前的计算状态和数据流向，对于理解执行上下文极为重要。”

其中`PC`（Program Counter）：指向当前正在执行的指令；

`SP`（Stack Pointer）：表示当前栈顶位置，关乎函数调用和局部变量的存储；

`a0`–`a7`：用于传递函数参数的寄存器，可反映初始化阶段的参数传递情况。”

![image-20251009221210301](./img/image-20251009221210301.png)

#### 查看寄存器:

输入命令`(gdb)i r`查看所有寄存器的值，输出如下：

“`ra             0x80000a02       0x80000a02`
`sp             0x8001bd80       0x8001bd80`
`gp             0x0      0x0`
`tp             0x8001be00       0x8001be00`
`t0             0x80200000       2149580800`
`t1             0x1      1`
`t2             0x1      1`
`fp             0x8001bd90       0x8001bd90`
`s1             0x8001be00       2147597824`
`a0             0x0      0`
`a1             0x82200000       2183135232`
`a2             0x80200000       2149580800`
`a3             0x1      1`
`a4             0x800    2048`
`a5             0x1      1`
`a6             0x82200000       2183135232`
`a7             0x80200000       2149580800`
`s2             0x800095c0       2147521984`
`s3             0x0      0`
`s4             0x0      0`
`s5             0x0      0`
`--Type <RET> for more, q to quit, c to continue without paging--c`
`s6             0x0      0`
`s7             0x8      8`
`s8             0x2000   8192`
`s9             0x0      0`
`s10            0x0      0`
`s11            0x0      0`
`t3             0x0      0`
`t4             0x0      0`
`t5             0x0      0`
`t6             0x82200000       2183135232`
`pc             0x80200000       0x80200000 <kern_entry>`
`dscratch       Could not fetch register "dscratch"; remote failure reply 'E14'`
`mucounteren    Could not fetch register "mucounteren"; remote failure reply 'E14'`”

至此，实验流程已经全部复现。

下面，我们使用GDB进行详细的调试以完成练习二的要求。

### GDB调试

#### 硬件初始化和固件启动：

首先，QEMU 模拟器启动后，会模拟加电复位过程，此时PC寄存器会被强制复位为**`0x1000`**。我们运行`make gdb`启动之后，RISC-V模拟器首先停止在`0x1000`这个地址，我们可以采用`x/10i $pc`命令来查看`0x1000`处的指令序列：

”`(gdb) x/10i $pc`
`=> 0x1000:      auipc   t0,0x0`
   `0x1004:      addi    a1,t0,32`
   `0x1008:      csrr    a0,mhartid`
   `0x100c:      ld      t0,24(t0)`
   `0x1010:      jr      t0`
   `0x1014:      unimp`
   `0x1016:      unimp`
   `0x1018:      unimp`
   `0x101a:      .insn   2, 0x8000`
   `0x101c:      unimp`“

这些指令是OpenSBI固件的开始部分，主要完成以下操作：

- `auipc t0,0x0`：将当前`PC`的高20位与0相加，然后存入`t0`，实际上`t0=0x1000`。
- `addi a1,t0,32`：将`t0+32=0x1020`存入a1，`0x1020`处存放了**设备树信息（DTB）**的地址。
- `csrr a0,mhartid`：读取当前硬件线程ID（mhartid）到a0。
- `ld t0,24(t0)`：从`t0+24=0x1018`处加载一个值到t0，`0x1018`处存放的是**OpenSBI主要代码**的地址。
- `jr t0`：跳转到t0指向的地址，即OpenSBI的主要代码。

对于上面提到的**设备树**，我们加以验证，通过查阅相关资料，我们了解到在设备树二进制文件（DTB）中，**魔数**（一个特殊的固定值，用来唯一标识某种文件格式或数据结构的开头）是**`0xd00dfeed`**（大端序）或**`0xedfe0dd0`**（小端序），那么我们只需要查看`0x1020`这个地址的魔数是否为这两个即可，运行命令`x/x 0x1020`之后，的确出现了对应的结果：

“`(gdb) x/x 0x1020`
`0x1020: 0xedfe0dd0`”

为了验证`0x1010`这里的跳转指令是否真的是跳转到**`0x80000000`**处，我们可以通过命令`si`以单条汇编指令为步长进行单步执行，通过命令`i r t0`来查看t0寄存器的值：

“`(gdb) i r t0`
`t0             0x0      0`
`(gdb) si`
`0x0000000000001004 in ?? ()`
`(gdb) si`
`0x0000000000001008 in ?? ()`
`(gdb) si`
`0x000000000000100c in ?? ()`
`(gdb) si`
`0x0000000000001010 in ?? ()`
`(gdb) si`
`0x0000000080000000 in ?? ()`
`(gdb) i r t0`
`t0             0x80000000       2147483648`”

可以看到，t0寄存器初始时为0x0，在执行完`ld t0,24(t0)`这条指令之后，t0寄存器的值变为`0x80000000`，之后再执行`jr t0`，就跳转到OpenSBI固件的初始地址处。除此之外，我们也可以运行命令`x/xg 0x1018`直接查看`0x1018`这个地址处保存的值，也同样为`0x80000000`。

#### **OpenSBI 初始化与内核加载**

同样的，在**`0x80000000`**这个地址处，我们也运行命令`x/10i $pc`，查看接下来的10条指令。在此之前，要在`0x80000000`处打下一个断点，通过`b *0x80000000`完成这个操作，接着`continue`就可以停止在`0x80000000`这个位置：

”`(gdb) b *0x80000000`
`Breakpoint 1 at 0x80000000`
`(gdb) c`
`Continuing.`

`Breakpoint 1, 0x0000000080000000 in ?? ()`
`(gdb) x/10i $pc`
`=> 0x80000000:  csrr    a6,mhartid`
   `0x80000004:  bgtz    a6,0x80000108`
   `0x80000008:  auipc   t0,0x0`
   `0x8000000c:  addi    t0,t0,1032`
   `0x80000010:  auipc   t1,0x0`
   `0x80000014:  addi    t1,t1,-16`
   `0x80000018:  sd      t1,0(t0)`
   `0x8000001c:  auipc   t0,0x0`
   `0x80000020:  addi    t0,t0,1020`
   `0x80000024:  ld      t0,0(t0)`“

这些指令是OpenSBI的初始化代码，由于OpenSBI初始化操作的指令数量太多，我们只列出来一部分。在进行完初始化操作之后，OpenSBI 就会准备开始加载并启动操作系统内核。

#### **内核启动执行**

OpenSBI完成相关操作之后，就会跳转到**`0x80200000`**这个地址，开始执行操作系统的初始化代码。同样，我们通过`b *0x80200000`在这里打下断点，然后`continue`执行到这一点。

“`(gdb) b *0x80200000`
`Breakpoint 2 at 0x80200000: file kern/init/entry.S, line 7.`
`(gdb) c`
`Continuing.`

`Breakpoint 2, kern_entry () at kern/init/entry.S:7`
`7           la sp, bootstacktop`”

接着，通过`x/10i $pc`查看接下来的十条指令，这是`kern_entry`的开始：

“`(gdb) x/10i $pc`

`=> 0x80200000 <kern_entry>:     auipc   sp,0x3`
   `0x80200004 <kern_entry+4>:   mv      sp,sp`
   `0x80200008 <kern_entry+8>:   j       0x8020000a <kern_init>`
   `0x8020000a <kern_init>:      auipc   a0,0x3`
   `0x8020000e <kern_init+4>:    addi    a0,a0,-2`
   `0x80200012 <kern_init+8>:    auipc   a2,0x3`
   `0x80200016 <kern_init+12>:   addi    a2,a2,-10`
   `0x8020001a <kern_init+16>:   addi    sp,sp,-16`
   `0x8020001c <kern_init+18>:   li      a1,0`
   `0x8020001e <kern_init+20>:   sub     a2,a2,a0`”

通过与entry.s对照，`0x80200000`处的指令是`auipc sp,0x3`，对应的就是`la sp, bootstacktop`这条指令，为C语言函数调用分配栈空间，准备C语言运行环境。

然后跳转到`0x8020000a`，即`kern_init`，对应`tail kern_init`这条指令，继续运行`si`，我们进入到了init.c中。

在init.c内部，我们通过`memset`函数，把`edata`到`end`之间的内存区域清零，即用于初始化未初始化的数据段（BSS段）为0；通过`cprintf`函数，打印操作系统启动的信息。其中，`cprintf`函数的实现逻辑为`sbi.c->console.c->stdio.c`。

阐述完了所有的调试流程之后，我们来回答练习二中提到的问题：

### Q1：RISC-V 硬件加电后最初执行的几条指令位于什么地址？

位于`0x1000`，这是QEMU模拟CPU的复位地址。在`0x1000`、`0x1004`、`0x1008`、`0x100c`、`0x1010`位置的五条指令在反汇编部分已经列出。当`0x1010`执行指令`jr t0`之后，地址跳转到`0x80000000`，即OpenSBI固件的初始地址处。

### Q2：它们主要完成了哪些功能？

- `0x1000`处的指令是OpenSBI固件的入口，主要完成：
	1. 设置设备树地址（DTB）到a1寄存器，用于之后内核解析DTB，并根据其中的信息来初始化硬件。
	2. 读取当前硬件线程ID（mhartid）到a0寄存器。
	3. 从`0x1018`处加载OpenSBI主要代码的地址，并跳转到该地址（`0x80000000`）。
- `0x80000000`处的OpenSBI代码主要完成：
	1. OpenSBI的初始化。
	2. 完成初始化操作之后，将控制权转交给操作系统内核（跳转到`0x80200000`）。

通过以上步骤，硬件加电后经过OpenSBI固件的初始化，最终将控制权转交给操作系统内核。

另外，我们这里列出来一些常见的gdb内存查看指令，以方便以后进行调试，在GDB中，内存查看命令的格式如下：
**`x/（数量）（格式）（单位） 地址`**

格式说明符：

| 字符 | 格式         | 字符 | 格式   |
| ---- | ------------ | ---- | ------ |
| x    | 十六进制     | f    | 浮点数 |
| d    | 有符号十进制 | a    | 地址   |
| u    | 无符号十进制 | i    | 指令   |
| o    | 八进制       | c    | 字符   |
| t    | 二进制       | s    | 字符串 |

单位说明符：

| 字符      | 单位  | 字符          | 单位  |
| --------- | ----- | ------------- | ----- |
| b（byte） | 1字节 | h（halfword） | 2字节 |
| w（word） | 4字节 | g（giant）    | 8字节 |





## 知识点

###  1. Bootloader (OpenSBI) 和内核启动

在操作系统执行之前，必然有一个其他程序执行，作为“先锋队”，把操作系统加载到内存，然后功成身退，把CPU的控制权交给操作系统。OpenSBI固件 正是在QEMU模拟的 RISC-V 计算机中的 Bootloader，负责启动时加载操作系统内核并将控制权交给操作系统。

实际上，在 Qemu 开始执行任何指令之前，首先要将作为 bootloader 的 OpenSBI.bin 加载到物理内存以物理地址 0x80000000 开头的区域上，然后将操作系统内核加载到QEMU模拟的硬盘中（Qemu指定默认将内核镜像 os.bin 加载到 Qemu 物理内存以地址 0x80200000 开头的区域上）。

![image-20251010122754463](./img/image-20251010122754463.png)

> 在计算机启动时，虽然底层架构不同（x86 vs RISC-V），但核心思想类似，都是一个从底层固件到高级操作系统的“接力”过程。即 固件 -> 引导程序 -> 操作系统 的传导链条，而Bootloader正是其中的引导程序，是操作系统与硬件之间的“桥梁”。在QEMU中，它通过OpenSBI实现，在x86系统中则是通过 BIOS 或 UEFI 实现。



### 2. 特权级和 ecall 指令

RISC-V 有四种特权级别：用户模式（U）、超级用户模式（S）、机器模式（M）。OpenSBI 运行在机器模式，通过 `ecall` 指令进行跨特权级的调用。

| Level | Encoding | 全称                       | 简称 |
| ----- | -------- | -------------------------- | ---- |
| 0     | 00       | User/Application           | U    |
| 1     | 01       | Supervisor                 | S    |
| 2     | 10       | Reserved(目前未使用，保留) |      |
| 3     | 11       | Machine                    | M    |

在源码的 kern_init 中，我们需要实现可视化的打印输出，但是由于此时操作系统还并未完成加载，因此无法调用现有运行库，只能直接通过最底层的硬件接口来进行实现。QEMU 内置的 OpenSBI 固件为我们提供了一个最原始的“输出一个字符”的接口，而为了在内核中调用该固件（也就是在S等级中调用M等级的接口），我们正是通过ecall指令实现这种跨越特权级别的调用。

> 操作系统通常运行在一个特权模式下（如内核模式），这使得操作系统能够直接访问硬件资源。在 x86 系统中，这对应于 ring 0 和 ring 3，而在 RISC-V 中则对应于 M、S、U 等模式



### 3. ELF 与 BIN 两种可执行文件

操作系统内核的可执行文件可以是 ELF 格式（复杂的格式，包含头部信息和段信息）或 BIN 格式（较为简单的格式，直接指定加载地址）。在当前实验中，执行make时，GNU 会编译所有的操作系统源代码，用 ld（链接器）工具把目标文件链接起来，生成一个内存布局合适的 ELF 文件，然后用 objcopy 工具将该 ELF 文件转换为 BIN 文件，作为 bootloader 的 OpenSBI 最终将该 BIN 文件加载到 QEMU 里运行（因为 OpenSBI 无法直接处理复杂的 ELF 文件）。



### 4. 内存布局与链接脚本

上面所说的过程中很重要的一点在于安排好 ELF 文件的内存布局，而这个是依赖链接脚本实现的。链接脚本的作用就是描述怎样把输入文件（.o）的 section 映射到输出文件（.elf）的 section，同时规定这些 section 的内存布局。实验代码中的链接脚本在 tools/kernel.ld 中给出，如果不提供链接脚本，`ld` 会使用默认的一个链接脚本，但这个默认脚本并不适合链接一个操作系统内核。

说回内存布局，一般来说，一个程序按照功能不同会分为下面这些段：

- `.text` 段，即代码段，存放汇编代码；
- `.rodata` 段，即只读数据段，顾名思义里面存放只读数据，通常是程序中的常量；
- `.data` 段，存放被初始化的可读写数据，通常保存程序中的全局变量；
- `.bss` 段，存放被初始化为 00 的可读写数据，与 `.data` 段的不同之处在于我们知道它要被初始化为 00，因此在可执行文件中只需记录这个段的大小以及所在位置即可，而不用记录里面的数据。
- `stack`，即栈，用来存储程序运行过程中的局部变量，以及负责函数调用时的各种机制。它从高地址向低地址增长；
- `heap`，即堆，用来支持程序运行过程中内存的动态分配，比如说你要读进来一个字符串，在你写程序的时候你也不知道它的长度究竟为多少，于是你只能在运行过程中，知道了字符串的长度之后，再在堆中给这个字符串分配内存。

而在本实验中，使用 tools/kernel.ld 这个链接脚本定义的内核内存布局，包括了代码段（`.text`）、数据段（只读数据``.rodata`、 `.data`、小数据`.sdata`）、未初始化数据段（`.bss`）等。除此之外，链接脚本中的 `BASE_ADDRESS` 还设置了内核的加载地址为 `0x80200000`，保证内核代码能够正确加载和运行。

> 内存管理是操作系统的重要命题，操作系统需要管理和分配内存，确保每个进程或内核模块的代码和数据能正确加载到内存中，避免冲突。而操作系统将程序加载到内存时，需要正确设置程序的内存布局，以确保程序能够正确执行。链接器和加载器是这一过程中的关键组件。



### 5.输入输出封装 (SBI Console)

在`kern_init` 函数中，除了初始化内核环境，另一个功能是向用户提供可视化打印输出。如上面所说，这一过程是通过 `ecall`指令跨级调用 `OpenSBI` 服务实现的。

通过 `ecall` 调用 `SBI` 服务类似于调用一个函数，然后按照固定的规则传递参数（后面会学习到这就是系统调用的调用格式）、接收返回值。具体调用过程如下：

1. 指定服务编号：将想要调用的 `SBI` 功能编号（例如，`SBI_CONSOLE_PUTCHAR` = 1）放入指定的寄存器（通常是 a7 或 x17）。
2. 传递参数：根据 `RISC-V` 的函数调用约定（Calling Convention），将参数放入寄存器 `a0`, `a1`, `a2`（即 `x10`, `x11`, `x12`）。
3. 执行调用：执行 `ecall` 指令。`CPU` 会 trap 到 `M` 模式，由 `OpenSBI` 固件处理请求。
4. 获取返回值：处理完成后，`OpenSBI` 会将返回值放入 `a0`（`x10`）寄存器，然后返回。

但是问题在于，在 `C` 语言中，我们无法直接执行 `ecall` 这样的特定指令，也无法精确控制哪个变量放入哪个寄存器。因此，我们必须借助内联汇编（`Inline Assembly`） 来“手动”完成上述步骤，将底层指令的调用封装成一个对 `C` 语言友好的函数。

首先实现了一个通用的 SBI 调用函数 `sbi_call`，随后基于通用的 `sbi_call`，封装出专用的字符输出函数`sbi_console_putchar`，最终封装为了高级的输出函数 `cputs` 和 `cprintf` 等。

> 实验中的封装过程与操作系统提供 I/O 系统的设计思路是类似的，都是通过封装硬件接口来提供高层抽象，允许上层程序更简单地调用函数实现功能，而无需关心硬件的具体细节。





## 实验未涉及的OS知识点

- **进程与线程管理：**实验的最小内核只有一个 `kern_init()` 函数，没有实现进程、线程或调度机制
- **内存管理：**实验只规定了内核加载在 `0x80200000` 起始的物理地址，没有涉及虚拟地址映射，也没有页表或内存分配；只停留在“物理地址空间”的层面，还没进入“虚拟内存管理”阶段
- **文件系统：**虽然 QEMU 模拟了“硬盘”，但还没真正实现任何文件系统逻辑
- **安全与保护机制：**RISC-V 的多级特权结构（M/S/U 模式）已出现，但我们始终运行在 S 模式，没有切换到 U 模式执行用户程序，因此“保护机制”只是理论存在
- **系统启动之后的用户空间：**我们的系统停在 `while(1);` 的死循环，还没有加载任何用户态程序